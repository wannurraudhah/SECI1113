# -*- coding: utf-8 -*-
"""Assignment 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MQtPUHOGcl_Auk1rWnYzzoce_Y4xSaNW
"""

#question 1
import numpy as np

# Define the matrix A
A = np.array([
    [0, 11, -5],
    [-2, 17, -7],
    [-4, 26, -10]
])

# Part (a): Characteristic polynomial
def characteristic_polynomial(matrix):
    # Compute the characteristic polynomial of matrix A
    return np.poly(matrix)

char_poly = characteristic_polynomial(A)

# Part (b): Power method to find the dominant eigenvalue and eigenvector
def power_method(matrix, v0, epsilon=0.005, max_iterations=1000):
    v = v0 / np.linalg.norm(v0)
    lambda_old = 0
    for _ in range(max_iterations):
        w = np.dot(matrix, v)
        v = w / np.linalg.norm(w)
        lambda_new = np.dot(v.T, np.dot(matrix, v))
        if np.abs(lambda_new - lambda_old) < epsilon:
            break
        lambda_old = lambda_new
    return lambda_new, v / v[2]  # Normalize so the last element is 1

v0_b = np.array([0, 1, 1])
lambda_1, eigenvector_1 = power_method(A, v0_b)
lambda_1 = round(lambda_1)

# Part (c): Shifted Power method to find the smallest eigenvalue and eigenvector
def shifted_power_method(matrix, v0, lambda_1, epsilon=0.005, max_iterations=1000):
    I = np.identity(matrix.shape[0])
    shifted_matrix = matrix - lambda_1 * I
    lambda_shifted, v_shifted = power_method(shifted_matrix, v0, epsilon, max_iterations)
    lambda_3 = lambda_shifted + lambda_1
    return lambda_3, v_shifted / v_shifted[2]  # Normalize so the last element is 1

v0_c = np.array([1, 0.25, 1])
lambda_3, eigenvector_3 = shifted_power_method(A, v0_c, lambda_1)
lambda_3 = round(lambda_3)

# Printing the results
print("Part (a): Characteristic polynomial")
print(f"The characteristic polynomial of matrix A is: {np.round(char_poly, 3)}")

print("\nPart (b): Dominant eigenvalue and eigenvector")
print(f"The dominant eigenvalue (λ1) is: {lambda_1}")
print(f"The corresponding eigenvector is: {np.round(eigenvector_1, 3)}")

print("\nPart (c): Smallest eigenvalue and eigenvector using Shifted Power Method")
print(f"The smallest eigenvalue (λ3) is: {lambda_3}")
print(f"The corresponding eigenvector is: {np.round(eigenvector_3, 3)}")

#question 2
import numpy as np

# Given data points for both Newton and Lagrange interpolation
T = np.array([5, 20, 30, 50, 55])
mu = np.array([0.0800, 0.0150, 0.0090, 0.0060, 0.0055])

# Newton interpolation
# Create a table to hold divided differences
n = len(T)
div_diff = np.zeros((n, n))
div_diff[:,0] = mu

# Calculate divided differences
for j in range(1, n):
    for i in range(n - j):
        div_diff[i,j] = (div_diff[i+1,j-1] - div_diff[i,j-1]) / (T[i+j] - T[i])

# Extract the coefficients for the Newton polynomial
coefficients = div_diff[0, :]

# Newton interpolation polynomial evaluation function
def newton_interpolation(T_values, coefficients, x):
    n = len(coefficients)
    result = coefficients[0]
    product_term = 1.0
    for i in range(1, n):
        product_term *= (x - T_values[i-1])
        result += coefficients[i] * product_term
    return result

# Estimate viscosity at T = 40°C using Newton interpolation
T_estimate = 40
mu_estimate_newton = newton_interpolation(T, coefficients, T_estimate)

# Lagrange interpolation
# Lagrange interpolation polynomial evaluation function
def lagrange_interpolation(T_values, mu_values, x):
    n = len(T_values)
    result = 0.0
    for i in range(n):
        term = mu_values[i]
        for j in range(n):
            if j != i:
                term *= (x - T_values[j]) / (T_values[i] - T_values[j])
        result += term
    return result

# Estimate viscosity at T = 40°C using Lagrange interpolation
mu_estimate_lagrange = lagrange_interpolation(T, mu, T_estimate)

# Print the output
print(f"Estimated viscosity at T = {T_estimate}°C using Newton interpolation is {mu_estimate_newton:.6f}")
print(f"Estimated viscosity at T = {T_estimate}°C using Lagrange interpolation is {mu_estimate_lagrange:.6f}")

#question 3
#least square approximation
import numpy as np

# Add the input data (x, y)
x_d = np.array([10, 16, 25, 40, 60])
y_d = np.array([94, 118, 147, 180, 230])

# Fit a degree 1 polynomial (linear fit)
y_est = np.polyfit(x_d, y_d, 1)

# Extract and round the coefficients
a0 = round(y_est[1], 2)
a1 = round(y_est[0], 2)

# Print the coefficients
print("a0 =", a0)
print("a1 =", a1)

#Question 4
def f(x):
    return 2*x**3 + x**2 - 4

# Function to calculate numerical derivatives
def numerical_derivative(f, x, h):
    # Three-Point Formula for f'(x)
    three_point_f_prime = (f(x+h) - f(x-h)) / (2*h)

    # Five-Point Formula for f'(x)
    five_point_f_prime = (-f(x+2*h) + 8*f(x+h) - 8*f(x-h) + f(x-2*h)) / (12*h)

    # Three-Point Formula for f''(x)
    three_point_f_double_prime = (f(x+h) - 2*f(x) + f(x-h)) / (h**2)

    # Five-Point Formula for f''(x)
    five_point_f_double_prime = (-f(x+2*h) + 16*f(x+h) - 30*f(x) + 16*f(x-h) - f(x-2*h)) / (12*h**2)

    return three_point_f_prime, five_point_f_prime, three_point_f_double_prime, five_point_f_double_prime

# Given values
x = 2.5
h = 0.5

# Calculate numerical derivatives
three_point_f_prime, five_point_f_prime, three_point_f_double_prime, five_point_f_double_prime = numerical_derivative(f, x, h)

# Print results with labels
print(f"Five point central f'(2.5): {five_point_f_prime}")
print(f"Five point central f''(2.5): {five_point_f_double_prime}")
print(f"Three point central f'(2.5): {three_point_f_prime}")
print(f"Three point central f''(2.5): {three_point_f_double_prime}")

# Calculate actual values of f'(2.5) and f''(2.5)
x_actual = 2.5

# Actual value for f'(2.5)
f_prime_actual = 6*x_actual**2 + 2*x_actual

# Actual value for f''(2.5)
f_double_prime_actual = 12*x_actual + 2

print(f"\nActual value of f'(2.5): {f_prime_actual}")
print(f"Actual value of f''(2.5): {f_double_prime_actual}")

# Calculate errors for each estimation
error_five_point_f_prime = abs(five_point_f_prime - f_prime_actual)
error_five_point_f_double_prime = abs(five_point_f_double_prime - f_double_prime_actual)
error_three_point_f_prime = abs(three_point_f_prime - f_prime_actual)
error_three_point_f_double_prime = abs(three_point_f_double_prime - f_double_prime_actual)

print(f"\nError in five point central f'(2.5): {error_five_point_f_prime}")
print(f"Error in five point central f''(2.5): {error_five_point_f_double_prime}")
print(f"Error in three point central f'(2.5): {error_three_point_f_prime}")
print(f"Error in three point central f''(2.5): {error_three_point_f_double_prime}")

# Calculate actual value of f(2.5)
f_actual = f(x_actual)
print(f"\nActual value of f(2.5): {f_actual}")

#question 5.1
#Trapezoidal Method
import numpy as np

# Define function to integrate
def f(x):
    return 2 / (1 + 5 * x**2)

# Implementing trapezoidal method
def trapezoidal(x0, xn, n):
    # Calculating step size
    h = (xn - x0) / n
    # Finding sum
    integration = f(x0) + f(xn)
    for i in range(1, n):
        k = x0 + i * h
        integration += 2 * f(k)
    # Finding final integration value
    integration *= h / 2
    return integration

# Input section
lower_limit = float(input("Enter lower limit of integration: "))
upper_limit = float(input("Enter upper limit of integration: "))
sub_interval = int(input("Enter number of sub intervals: "))

# Call trapezoidal() method and get result
result = trapezoidal(lower_limit, upper_limit, sub_interval)
print("Integration result by Trapezoidal method is: %0.4f" % result)

#question 5.2
#Simpson's 1/3 Method
import numpy as np

# Define function to integrate
def f(x):
    return 2 / (1 + 5 * x**2)

# Implementing Simpson's 1/3 method
def simpson13(x0, xn, n):
    # Ensure the number of sub-intervals is even
    if n % 2 != 0:
        raise ValueError("Number of sub-intervals must be even.")

    # Calculating step size
    h = (xn - x0) / n
    # Finding sum
    integration = f(x0) + f(xn)
    for i in range(1, n):
        k = x0 + i * h
        if i % 2 == 0:
            integration += 2 * f(k)
        else:
            integration += 4 * f(k)
    # Finding final integration value
    integration *= h / 3
    return integration

# Input section
lower_limit = float(input("Enter lower limit of integration: "))
upper_limit = float(input("Enter upper limit of integration: "))
sub_interval = int(input("Enter number of sub-intervals (must be even): "))

# Call simpson13() method to get result
try:
    result = simpson13(lower_limit, upper_limit, sub_interval)
    print("Integration result by Simpson's 1/3 method is: %0.4f" % result)
except ValueError as e:
    print(e)

#question 5.3
#Simpson's 3/8 Rule
import numpy as np

# Define function to integrate
def f(x):
    return 2 / (1 + 5 * x**2)

# Implementing Simpson's 3/8 method
def simpson38(x0, xn, n):
    # Ensure the number of sub-intervals is a multiple of 3
    if n % 3 != 0:
        raise ValueError("Number of sub-intervals must be a multiple of 3.")

    # Calculating step size
    h = (xn - x0) / n
    # Finding sum
    integration = f(x0) + f(xn)
    for i in range(1, n):
        k = x0 + i * h
        if i % 3 == 0:
            integration += 2 * f(k)
        else:
            integration += 3 * f(k)
    # Finding final integration value
    integration *= 3 * h / 8
    return integration

# Input section
lower_limit = float(input("Enter lower limit of integration: "))
upper_limit = float(input("Enter upper limit of integration: "))
sub_interval = int(input("Enter number of sub-intervals (must be a multiple of 3): "))

# Call simpson38() method to get result
try:
    result = simpson38(lower_limit, upper_limit, sub_interval)
    print("Integration result by Simpson's 3/8 method is: %0.4f" % result)
except ValueError as e:
    print(e)

#question 5.4
#Romberg integration
import numpy as np

# Romberg integration method to integrate a function from a to b.
def romberg_integration(func, a, b, n):
    # Initialize the Romberg table with zeros
    R = np.zeros((n, n))
    # Calculate the first column of the Romberg table using trapezoidal rule
    h = b - a
    R[0, 0] = 0.5 * h * (func(a) + func(b))

    for i in range(1, n):
        h /= 2
        sum_f = 0
        for k in range(1, 2**i, 2):
            sum_f += func(a + k * h)
        R[i, 0] = 0.5 * R[i-1, 0] + sum_f * h

    # Populate the rest of the Romberg table
    for j in range(1, n):
        for i in range(j, n):
            R[i, j] = (4**j * R[i, j-1] - R[i-1, j-1]) / (4**j - 1)

    # Return the integral approximation
    return R[n - 1, n - 1]

# Example usage:
def f(x):
    return 2 / (1 + 5 * x**2)  # Function to integrate

a = 0  # Lower limit
b = 3  # Upper limit
n = 4  # Number of iterations

result = romberg_integration(f, a, b, n)
print("Approximate integral using Romberg method is: %0.4f" % result)

