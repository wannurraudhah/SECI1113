# -*- coding: utf-8 -*-
"""Assignment 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HTqX7V0Mi6vimUPY7UsVI2MJD_wA8GQz
"""

import numpy as np

def bisection_method(func, a, b, tol):
    if func(a) * func(b) > 0:
        print("Failed computation for Bisection method.")
        return None
    else:
        iteration = 0
        print(f"{'Iteration':<10} {'a':<10} {'b':<10} {'f(a)':<15} {'f(b)':<20} {'c':<10} {'f(c)':<20}")
        while abs(b - a) >= tol:
            c = (a + b) / 2
            f_a = func(a)
            f_b = func(b)
            f_c = func(c)
            print(f"{iteration:<10} {a:<10.4f} {b:<10.4f} {f_a:<15.4f} {f_b:<15.4f} {c:<10.4f} {f_c:<15.4f}")
            if abs(f_c) < tol:
                print("Root found at c:", c) # for reference
                print(f"\nIn the {iteration}th iteration, the value of error f(c) = {f_c:.4f} < {tol}.")
                return c
            elif f_c * f_a < 0:
                b = c
            else:
                a = c
            iteration += 1
        c = (a + b) / 2
        print(f"\nThe value of error f(c) = {f_c:.4f} < {tol}.")
        return c

def f(x):
    return (3 * x) - np.exp(-x)

interval_to_use = (0.1, 1.5)
root = bisection_method(f, interval_to_use[0], interval_to_use[1], 0.0001)
print(f"\nTherefore, the calculation to find the root can be stopped. Hence, the root of the function in the interval [0.1, 1.5] is approximately: {root:.3f}")

import math

def f(x):
    return math.cos(x) + 2 * math.sin(x) + x**2

def f_prime(x):
    return -math.sin(x) + 2 * math.cos(x) + 2 * x

def secant_method(x0, x1, tol=1e-4, max_iter=100):
    for _ in range(max_iter):
        f_x0 = f(x0)
        f_x1 = f(x1)
        if abs(f_x1) < tol:
            return round(x1, 4)
        if f_x0 == f_x1:  # Avoid division by zero
            return None
        x2 = x1 - f_x1 * (x1 - x0) / (f_x1 - f_x0)
        x0, x1 = x1, x2
    return None

def newton_method(x0, tol=1e-4, max_iter=100):
    for _ in range(max_iter):
        f_x0 = f(x0)
        if abs(f_x0) < tol:
            return round(x0, 4)
        f_prime_x0 = f_prime(x0)
        if f_prime_x0 == 0:  # Avoid division by zero
            return None
        x1 = x0 - f_x0 / f_prime_x0
        x0 = x1
    return None

# Example usage:
x0_secant = 0
x1_secant = 1
x0_newton = 1

root_secant = secant_method(x0_secant, x1_secant)
root_newton = newton_method(x0_newton)

print(f"Root found by secant method: {root_secant}")
print(f"Root found by Newton's method: {root_newton}")